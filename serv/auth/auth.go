// Package auth provides an API to use GraphJin serv auth handles with your own application. Works with routers like chi and http mux.
// For detailed documentation visit https://graphjin.com
//
// Example usage:
/*
	package main

	import (
		"net/http"
		"path/filepath"
		"github.com/go-chi/chi"
		"github.com/dosco/graphjin/serv"
		"github.com/dosco/graphjin/serv/auth"
	)

	func main() {
		conf, err := serv.ReadInConfig(filepath.Join("./config", serv.GetConfigName()))
		if err != nil {
			panic(err)
		}

		useAuth, err := auth.NewAuth(conf.Auth, log, auth.Options{AuthFailBlock: true})
		if err != nil {
			panic(err)
		}

		r := chi.NewRouter()
		r.Use(useAuth)
		r.Get("/user", userInfo)

		http.ListenAndServe(":8080", r)
	}
*/
package auth

import (
	"context"
	"errors"
	"fmt"
	"github.com/dosco/graphjin/core"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"net/http"
	"strconv"
	"time"

	"github.com/dosco/graphjin/serv/auth/provider"
)

type JWTConfig = provider.JWTConfig

// Auth struct contains authentication related config values used by the GraphJin service
type Auth struct {
	// Enable development mode use to set credentials in the
	// header and vars for testing
	Development bool

	// Name is a friendly name for this auth config
	Name string
	// Type can be magiclink, rails, jwt or header
	Type string

	// Cookie is the name of the cookie used
	Cookie string

	// In certain cases like Magiclink the jwt cookie
	// is generated by us this helps set the secure parameter
	// of this cookie
	CookieHTTPS bool `mapstructure:"cookie_https"`

	// In certain cases like Magiclink the jwt cookie
	// is generated by us this helps set the expiry parameter
	// of this cookie (ex. "20m", "2h")
	CookieExpiry string `mapstructure:"cookie_expiry"`

	// Rails cookie authentication
	Rails struct {
		// Rails version is needed to decode the cookie correctly.
		// Can be 5.2 or 6
		Version string

		// SecretKeyBase is the cookie encryption key used in your Rails config
		SecretKeyBase string `mapstructure:"secret_key_base"`

		// URL is used for Rails cookie store based auth.
		// Example: redis://redis-host:6379 or memcache://memcache-host
		URL string

		// Password is set if needed by Redis or Memcache
		Password string

		// MaxIdle maximum idle time for the connection
		MaxIdle int `mapstructure:"max_idle"`

		// MaxActive maximum active time for the connection
		MaxActive int `mapstructure:"max_active"`

		// Salt value is from your Rails 5.2 and below auth config
		Salt string

		// SignSalt value is from your Rails 5.2 and below auth config
		SignSalt string `mapstructure:"sign_salt"`

		// AuthSalt value is from your Rails 5.2 and below auth config
		AuthSalt string `mapstructure:"auth_salt"`
	}

	// JWT  authentication
	JWT JWTConfig

	// Header authentication
	Header struct {
		// Name of the HTTP header
		Name string

		// Value if set must match expected value (optional)
		Value string

		// Exists if set to true then the header must exist
		// this is an alternative to using value
		Exists bool
	}

	// Magic.link authentication
	MagicLink struct {
		Secret string
	}

	// Gorilla cookie authentication
	Gorilla struct {
		// Type redis
		Type string

		Redis struct {
			// Network The network type, either tcp or unix.
			// Default is tcp.
			Network string

			// Addr host:port address.
			Addr string

			// Username Use the specified Username to authenticate the current connection
			// with one of the connections defined in the ACL list when connecting
			// to a Redis 6.0 instance, or greater, that is using the Redis ACL system.
			Username string

			// Password Optional password. Must match the password specified in the
			// requirepass server configuration option (if connecting to a Redis 5.0 instance, or lower),
			// or the User Password when connecting to a Redis 6.0 instance, or greater,
			// that is using the Redis ACL system.
			Password string

			// All redis option bellow use the default value when set to 0

			// DB Database to be selected after connecting to the server.
			DB int

			// MaxRetries Maximum number of retries before giving up.
			// Default is 3 retries.
			MaxRetries int `mapstructure:"max_retries"`

			// MinRetryBackoff Minimum backoff between each retry.
			// Default is 8 milliseconds; -1 disables backoff.
			MinRetryBackoff time.Duration `mapstructure:"min_retry_backoff"`

			// MaxRetryBackoff Maximum backoff between each retry.
			// Default is 512 milliseconds; -1 disables backoff.
			MaxRetryBackoff time.Duration `mapstructure:"max_retry_backoff"`

			// DialTimeout Dial timeout for establishing new connections.
			// Default is 5 seconds.
			DialTimeout time.Duration `mapstructure:"dial_timeout"`

			// ReadTimeout Timeout for socket reads. If reached, commands will fail
			// with a timeout instead of blocking. Use value -1 for no timeout and 0 for default.
			// Default is 3 seconds.
			ReadTimeout time.Duration `mapstructure:"read_timeout"`

			// WriteTimeout Timeout for socket writes. If reached, commands will fail
			// with a timeout instead of blocking.
			// Default is ReadTimeout.
			WriteTimeout time.Duration `mapstructure:"write_timeout"`

			// PoolSize Maximum number of socket connections.
			// Default is 10 connections per every CPU as reported by runtime.NumCPU.
			PoolSize int `mapstructure:"pool_size"`

			// MinIdleConns Minimum number of idle connections which is useful when establishing
			// new connection is slow.
			MinIdleConns int `mapstructure:"min_idle_connns"`

			// MaxConnAge Connection age at which client retires (closes) the connection.
			// Default is to not close aged connections.
			MaxConnAge time.Duration `mapstructure:"max_idle"`

			// PoolTimeout Amount of time client waits for connection if all connections
			// are busy before returning an error.
			// Default is ReadTimeout + 1 second.
			PoolTimeout time.Duration `mapstructure:"pool_timeout"`

			// IdleTimeout Amount of time after which client closes idle connections.
			// Should be less than server's timeout.
			// Default is 5 minutes. -1 disables idle timeout check.
			IdleTimeout time.Duration `mapstructure:"idle_timeout"`

			// IdleCheckFrequency Frequency of idle checks made by idle connections reaper.
			// Default is 1 minute. -1 disables idle connections reaper,
			// but idle connections are still discarded by the client
			// if IdleTimeout is set.
			IdleCheckFrequency time.Duration `mapstructure:"idle_check_frequency"`
		}

		Store struct {
			Prefix    string `mapstructure:"prefix"`
			UserIdKey string `mapstructure:"user_id_key"`
		}

		SessionOptions struct {
			Path   string
			Domain string
			// MaxAge=0 means no Max-Age attribute specified and the cookie will be
			// deleted after the browser session ends.
			// MaxAge<0 means delete cookie immediately.
			// MaxAge>0 means Max-Age attribute present and given in seconds.
			MaxAge   int `mapstructure:"max_age"`
			Secure   bool
			HttpOnly bool `mapstructure:"http_only"`
			// Defaults to http.SameSiteDefaultMode
			// 	SameSiteDefaultMode SameSite = iota + 1
			//	SameSiteLaxMode
			//	SameSiteStrictMode
			//	SameSiteNoneMode
			SameSite http.SameSite `mapstructure:"same_site"`
		} `mapstructure:"session_options"`
	}
}

type handlerFunc func(w http.ResponseWriter, r *http.Request) (context.Context, error)

type Options struct {
	// Return a HTTP '401 Unauthoized' when auth fails
	AuthFailBlock bool
}

func NewAuth(ac Auth, log *zap.Logger, opt Options) (
	func(next http.Handler) http.Handler, error) {
	var h handlerFunc
	var err error

	if ac.Development {
		h, err = SimpleHandler(ac)
		if err != nil {
			return nil, err
		}
	}

	switch ac.Type {
	case "rails":
		h, err = RailsHandler(ac)

	case "jwt":
		h, err = JwtHandler(ac)

	case "header":
		h, err = HeaderHandler(ac)

	// case "magiclink":
	// 	h, err = MagicLinkHandler(ac, next)

	case "gorilla":
		h, err = GorillaHandler(ac)

	case "", "none":
		return nil, nil

	default:
		return nil, fmt.Errorf("auth: unknown auth type: %s", ac.Type)
	}

	if err != nil {
		return nil, fmt.Errorf("%s: %s", ac.Type, err.Error())
	}

	return func(next http.Handler) http.Handler {
		ah := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			c, err := h(w, r)
			if err != nil && log != nil {
				log.Error("Auth", []zapcore.Field{zap.String("type", ac.Type), zap.Error(err)}...)
			}

			if err == err401 {
				http.Error(w, "401 unauthorized", http.StatusUnauthorized)
				return
			}

			if opt.AuthFailBlock && !IsAuth(c) {
				http.Error(w, "401 unauthorized", http.StatusUnauthorized)
				return
			}

			if c != nil {
				next.ServeHTTP(w, r.WithContext(c))
			} else {
				next.ServeHTTP(w, r)
			}
		})

		return ah
	}, nil
}

func SimpleHandler(ac Auth) (handlerFunc, error) {
	return func(_ http.ResponseWriter, r *http.Request) (context.Context, error) {
		c := r.Context()

		userIDProvider := r.Header.Get("X-User-ID-Provider")
		if userIDProvider != "" {
			c = context.WithValue(c, core.UserIDProviderKey, userIDProvider)
		}

		userID := r.Header.Get("X-User-ID")
		if userID != "" {
			c = context.WithValue(c, core.UserIDKey, userID)
		}

		userRole := r.Header.Get("X-User-Role")
		if userRole != "" {
			c = context.WithValue(c, core.UserRoleKey, userRole)
		}

		return c, nil
	}, nil
}

var err401 = errors.New("401 unauthorized")

func HeaderHandler(ac Auth) (handlerFunc, error) {
	hdr := ac.Header

	if hdr.Name == "" {
		return nil, fmt.Errorf("auth '%s': no header.name defined", ac.Name)
	}

	if !hdr.Exists && hdr.Value == "" {
		return nil, fmt.Errorf("auth '%s': no header.value defined", ac.Name)
	}

	return func(_ http.ResponseWriter, r *http.Request) (context.Context, error) {
		var fo1 bool
		value := r.Header.Get(hdr.Name)

		switch {
		case hdr.Exists:
			fo1 = (value == "")

		default:
			fo1 = (value != hdr.Value)
		}

		if fo1 {
			return nil, err401
		}
		return nil, nil
	}, nil
}

func IsAuth(c context.Context) bool {
	return c.Value(core.UserIDKey) != nil
}

func UserID(c context.Context) interface{} {
	return c.Value(core.UserIDKey)
}

func UserIDInt(c context.Context) int {
	v, ok := UserID(c).(string)
	if !ok {
		return -1
	}
	if v, err := strconv.Atoi(v); err == nil {
		return v
	}
	return -1
}
